%!TEX root = ../main.tex
The goal of this master thesis was to ease the use of Ant Colony Optimization in routing problems by creating an implementation with a high level of abstraction. After the analysis of existing ACO implementations for routing problems, it was found that implementing a framework was the most natural way to proceed. Because of the particularity of ACO, a high level of abstraction is hard to reach.

In chapter \ref{abstraction}, an analysis of the implementations of ACO for different routing problems (TSP, CVRP an VRPTW) shows that even if there is a lot of differences in the implementations, the principle of the algorithm is always the same. The way to solve the problems are very similar from a high-level perspective, but they differ significantly in implementation details. Some ants build solutions and these solutions are compared and used to update the pheromone trails. This is the principle that is used in chapter \ref{Framework} to build the framework. An \texttt{Ant} class is build to describe the behavior of the ants and a \texttt{Colony} class has the purpose of coordinating these ants. The inherintance capacity of Scala is used on these classes to change the implementation details that change from one problem to another.

 As presented in chapter \ref{Framework}, when very specific implementations (as the MACS for the VRPTW) are made, the \texttt{MyAnt} and \texttt{MyColony} classes override almost everything from the parent classes \texttt{Ant} and \texttt{Colony}. On the other hand, when different types of constraints are added to a CVRP, the cores method of the \texttt{Ant} and \texttt{Colony} classes are not modified but only the methods that describe how an ant chooses the cities to visit. Also, the other classes of the framework are well generalized as they permit to easily add constraints to the problem using the input file and the arguments of the main function.

Chapter \ref{tests} presents the results obtained with the framework on different problems. The first set of tests concern the resolutions of classical TSP, CVRP and VRPTW problems. It can be seen that, compared to other ACO implementations, there are good results with TSP and CVRP. The differences that are observable can be explained because of the fact that, in this thesis, we focus on the abstraction of ACO and not on the implementation of the most efficient method to solve these problems. A lot of different functions such as local search functions are used in the compared implementations. The tests with VRPTW instances give unsatisfactory results, but the interesting aspect to put forward is that all these implementations are made with the same framework, using the same classes, and where the implementation details which differ are contained in the two extended classes \texttt{MyAnt} and \texttt{MyColony}. The second set of tests presents the solving of "tuned" CVRP with new constraints. These tests aim to show that a user can modify and use the ACO framework to solve different specific problems and have consistent results. 

The goal of this master thesis, which was to abstract the ACO metaheuristic, is achieved through the framework developed. Nevertheless, some improvements can be done in future work. One of the reasons scala is used in this thesis is because it is a high level language with mixed paradigms: it uses pure object oriented and functional programming. As it is statically typed, it allows the writing of Domain Specific Language (DSL). Working on a DSL that permits to specify a routing problem in a way that can be used for the ants could be a serious improvement of this implementation. Scala, being high level, permits to do very specific things. A Scala expert could probably have implemented some specific details in another way. Finally, a great improvement that can be done is the use of parallelism in the implementation. The structure of the colony that runs a certain number of ants is particularly suitable for a parallel implementation where each ant has its own thread to build a solution. This could be a very interesting improvement as almost every CPU and GPU are currently built with multi-cores and multi-threads.
