%!TEX root = ../main.tex

In this chapter, we will describe some improvements that can be done on the algorithms of the Chapter~\ref{algos}.

\section{Ford-Fulkerson Scaling}
The Ford-Fulkerson algorithm has a pseudo-polynomial time complexity but there is a variant of this algorithm which has a polynomial time complexity. It is the Ford-Fulkerson with scaling algorithm. The scaling consists in looking for an augmenting path which has a large enough residual capacity. To do it, we use $G_\Delta$ which is $G$ with only the edges having a capacity $\geq \Delta$. \\

As long as there is an augmenting path in $G_\Delta$, we send flow through it. This is a $\Delta$-scaling phase. When a $\Delta$-scaling phase is ended, we divide $\Delta$ by 2 and begin the next $\Delta$-scaling phase. Initially, $\Delta = U$, with $U$ the maximum capacity of the graph.

\subsection{Complexity}
To compute the complexity of the Ford-Fulkerson Scaling algorithm, we need to know how many $\Delta$-scaling phases are possible, how many augmenting paths can be discovered at most in a $\Delta$-scaling phase and how an augmenting path is found.

\begin{itemize}
\item There is at most $O(log(U))$ $\Delta$-scaling phases because initially $\Delta = U = 2^{log(U)}$ and after each phase, $\Delta=\frac{\Delta}{2}$.
\item There is at most $O(|E|)$ augmenting paths in each $\Delta$-scaling phase. To prove it, let $f$ be the flow at the end of the $\Delta$-scaling phase and $f^*$ be the maximal flow. At the end of a $\Delta$-scaling phase, the total flow which we can add to $f$ to obtain $f^*$ is $\leq |E|*\Delta$. Since we know that in the next $\Delta$-scaling phase, $\Delta=\frac{\Delta}{2}$, there will be a maximum of $2|E|$ augmentations during the next phase.
\item We know that each augmenting path can be found in $O(|E|)$
\end{itemize}

The Ford-Fulkerson Scaling algorithm is thus bounded by $O(|E|^2* log(U))$.

\section{Preflow-push heuristics}

In Section~\ref{sec:preflow}, we defined the generic preflow-push algorithm. In this algorithm, we do not make a particular choice when it comes to push on a vertex. In this section, we will define two heuristics that aims to reduce the number of non-saturing pushes which is the bottle neck of the generic preflow-push algorithm.

\subsection{FIFO heuristic}

This algorithm examines the active vertices in the first-in, first-out (FIFO) order. The set of the active vertices is now a queue. The algorithm will always choose the first vertex from the queue while there is active vertices. The algorithm terminates when the queue is empty. 

\subsubsection{Complexity}

To analyze the complexity of the FIFO preflow-push algorithm, we must define the concept of a \textit{vertex examination}. We call vertex examination the sequence of operation that make an active vertex inactive or relabeled. For example, the algorithm could perfoms several saturing pushes, leaving the first vertex of the queue active. Then the algorithm could make a non-saturing push or could relabel the vertex. We refer to this sequence of operations as a vertex examination.\\

We will partition the total number of vertex examinations into phases. The first phase consists of the vertex examinations of the vertices that becomes actives (the neighbors of the source) in the preprocess operation (Algorithm~\ref{preprocess}). After all thoses specifics vertices has been examinated, we enter in the second phase. The second phase consists of the vertex examinations of the vertices that are in the queue at this moment (i.e. when the vertices of the first phase has been all examinated). And so on.\\

To bound the number of phases in the algorithm, we define the potential function $\phi = max\{h(i) : \text{i is active}\}$ where $h(i)$ is the height of the vertex $i$.

During a phase, the algorithm can perfoms no relabel operation or at least one. In the first case, the excess of every vertex that was active at the beginning of the phase moves to vertices with smaller height labels. $\phi$ decrease by at least one unit. In the second case, when the algorithm perfoms at least one relabel operation during a phase, $\phi$ might increase by as much as the maximum increase in any height label. As we know that the maximum of relabel operation is $2*|V|^2$ (because each label can increases at most $2*|V|$ times), the total increase in $\phi$ over all phases is at most $2*|V|^2$.

With these two cases, we can bound the total number of phases: $2*|V|^2 + |V|$. The FIFO preflow-push algorithm runs in $O(|V|^3)$.

\subsection{Highest label heuristic}

This algorithm always pushes flow from the active vertex with the highest height label. 

\subsubsection{Complexity}

It is fearly easy to develop an $O(|V|^3)$ bound for this algorithm. We define the function $h^{*} = max\{h(i): \text{i is active}\}$. First, the algorithm examine the active vertices with distance labels equal to $h^{*}$ and pushes flow to active vertices with distance labels equals to $h^{*}-1$ and these vertices, in turn, push flow to active vertices with distance labels equals to $h^{*}-2$, and so on. These operations stop when there is no more active vertices or the algorithm relabel a vertex. If the algorithm relabel a vertex, these operations are repeated. In the worst case, the algorithm make $|V| - 1$ vertex examinations and then relabel a vertex. As we know that the maximum of relabel operation is $2*|V|^2$, the highest label preflow-push algorithm runs in $O(|V|^3)$.\\

However, this bound is rather loose and can be improved by a more clever analysis. We will first define some concepts and functions used to compute the complexity of the algorithm.\\

The \textit{set of admissible arcs} is the set, at some point of the execution of the algorithm, of all the arcs where the origin height is greater than one of the destination height. This set forms a \textit{forest}, which is a set of trees, because it has at most $n - 1$ arcs, has at most one outgoing arc per vertex, and does not contain any cycle. The root of each of these trees is the vertex without any outgoing arc. 

For any vertex $i \in V$, we denote $D(i)$ the set of descendants of that vertex in the set of admissible arcs. The height label of the descendants of any vertex $i$ will always be higher than $h(i)$. 

An active vertex with no active descendants (other than itself) will be called a \textit{maximal active vertex}. We denote the set of the maximal active vertices $H$.

We define the potential function $\phi = \sum_{i \in H} \phi(i)$ with $\phi(i) = max\{0, K + 1 - |D(i)|\}$ where $K$ will be defined later. For any vertex $i$, $\phi(i)$ is at most $K$ because $|D(i)| \ge 1$.\\

We will now see how each operations performed by the algorithm will change the value of $\phi$. First, a non-saturing push on the arc $(i, j)$ will make $i$ inactive and $j$ might become a new maximal active vertex. Since $|D(j)| > |D(i)|$, this push increase $\phi(i) + \phi(j)$ by at least one if $|D(i)| \le K$. When a saturing push occurs on the arc $(i, j)$, this arc become inadmissible and will be no more in the current forest (the set of admissible arcs). The vertex $i$ is still a maximal active vertex and $j$ might become a new maximal vertex. This operation increase $\phi$ up to $K$ units. Let's consider now a relabel operation on the vertex $i$. This vertex has no admissible arc because we relabel it. Thus, this vertex is a root vertex in the current forest and it has no active proper decendants. After the relabel operation, all the incoming arcs at vertex $i$ become inadmissible. Therefore, all the currend arc entering vertex $i$ will no longer belong to the current forest. The relabel operation decrease the number of descendants of $i$ to one: $\phi$ increase by at most $K$. The last operation is to introduce new arcs in the current forest. This does not create new maximal active vertices and might remove maximal active vertices and increase the number of descendants of some vertices. $\phi$ does not increase.\\

To compute the worst-case, we define $h_{max} = max\{h(i) : i\text{ is active}\}$. A phase is the sequence of pushes during which $d_{max}$ remains unchanged. There is $O(|V|^2)$ phases because there can be more than $2*|V|^2$ relabel operations. We disinguish two types of phases: \textit{cheap} phases and \textit{expensive} phases. A phase is cheap when it perfoms at most $\frac{2*|V|}{K}$ non-saturing pushes and expensive otherwise. The number of non-saturing pushes in cheap phases is at most $O(|V|^2 * \frac{2*|V|}{K}) = O(\frac{|V|^3}{K})$.

By definiation, an expensive phase performs at least $\frac{2*|V|}{K}$ non-saturing pushes. Since the network can contain at most $\frac{|V|}{K}$ vertices witk $K$ descendants or more, at least $\frac{|V|}{K}$ non-saturing pushes must be from vertices with fewer than $K$ descendants. AS we said earlier, the total increase of $\phi$ due to saturing pushes and relabels is at most $O(|V|*|E|*K)$. The algorithm perform $O(|V|*|E|*K)$ non-saturing pushes in expensive phases.\\

By balancing the complexity of each case, we obtain the optimal value of $K$ when both are equal: $\frac{|V|^3}{K} = |V|*|E|*K$ or $K = \frac{|V|}{\sqrt{|E|}}$. We have now the number of non-saturing pushes: $O(|V|^2*\sqrt{|E|})$ which is the complexity of our algorithm.\\


To be able to choose an active vertex with the highest label quickly, we implemented a custom data structure based on the idea of Fran\c cois Aubry, PhD student at UCL. This data structure will be described in the next sub section.

\subsubsection{The Tower}

The data structure is divided in two parts: the tower and the next array. The tower, as shown on Figure~\ref{fig:tower}, is a array of linked lists of size $|V|*2$. The tower can be defined as follow: $tower(k) = \{i : i \text{ is active and } h(i) = k\} \text{ } \forall \text{ } 0 \le k < |V|*2$. When a vertex become active, he is added to the linked list at the indice of the array corresponding to his height. The next array is an integer array of size $|V|*2$ where all of his element are pointers of the next element in the data structure. For example, let's take the case of the Figure~\ref{fig:TheTower}, where there is no active vertices with heights between 3 and $2*|V|-1$ (all active vertices are shown in the figure). The first (top) element of the data structure is 9 and the second 6. In the next array, the value at the indice $h(9)$ must be equals to $h(6)$ and so on. Note that the minimum height of the active vertices must point to $-1$ because there is no following elements. A variable is used to point at the top of the tower. Here is the operations needed:

\begin{description}
	\item[getTop] Give the top element of the tower. It is used when the highest label preflow-push algorithm must examinates a vertex;
	\item[add] When an vertex become active, the vertex is added to the tower;
	\item[updateTop] Used when the top vertex is relabeled;
	\item[removeTop] Used when the top vertex is no longer active (i.e. when there is a non-saturing push);
	\item[isEmpty] Used to know when the tower is empty. When the tower is empty, the algorithm terminates.
\end{description}

We wish to clarify that we have not found any implementation of this heuristic anywhere.

\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=.4]{images/thetower.png}
  \caption{The tower}
  \label{fig:tower}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=.4]{images/thenext.png}
  \caption{The next array}
  \label{fig:next}
\end{subfigure}
\caption{The data structure}
\label{fig:TheTower}
\end{figure}


