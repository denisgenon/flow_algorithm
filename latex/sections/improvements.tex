%!TEX root = ../main.tex

In this chapter, we will describe some improvements found on the literature \cite{scaling,networkflows} that can be done on the algorithms presented in Chapter~\ref{algos}.

\section{Ford-Fulkerson Scaling}
The Ford-Fulkerson algorithm has a pseudo-polynomial time complexity, making it very slow when the maximum capacity of the edges is high. But there is a variant of this algorithm which has a polynomial time complexity, the Ford-Fulkerson with scaling. The scaling consists in looking for an augmenting path which has a large enough residual capacity. To do it, we use $G_\Delta$ which is $G$ with only the edges having a capacity greater than or equal to $\Delta$ \cite{lectu5}. \\

As long as there is an augmenting path in $G_\Delta$, we send flow through it. This is a $\Delta$-scaling phase. When a $\Delta$-scaling phase is ended, which means that there are no more augmenting paths in $G_\Delta$, we divide $\Delta$ by 2 and begin the next $\Delta$-scaling phase, looking for new augmenting paths in $G_\Delta$. Initially $\Delta = U$, with $U$ the maximum capacity of the graph.

\subsection{Complexity}
To compute the complexity of the Ford-Fulkerson Scaling algorithm, we need to know how many $\Delta$-scaling phases are possible, how many augmenting paths can be discovered at most in a $\Delta$-scaling phase and how an augmenting path is found \cite{lectu7}.

\begin{itemize}
\item There is at most $O(log(U))$ $\Delta$-scaling phases because initially $\Delta = U = 2^{log(U)}$ and after each phase, $\Delta=\frac{\Delta}{2}$.
\item There is at most $O(|E|)$ augmenting paths in each $\Delta$-scaling phase. To prove it, let $f$ be the flow at the end of the $\Delta$-scaling phase and $f^*$ be the maximal flow. At the end of a $\Delta$-scaling phase, the total flow which we can add to $f$ to obtain $f^*$ is less than or equal to $|E| \cdot \Delta$ so $f^*-f \leq |E| \cdot \Delta$. Since we know that in the next $\Delta$-scaling phase, $\Delta'=\frac{\Delta}{2}$, there will be a maximum of $2|E|$ augmentations during the next phase \cite{lectu5}.
\item We know that each augmenting path can be found in $O(|E|)$.
\end{itemize}

The Ford-Fulkerson Scaling algorithm is thus bounded by $O(|E|^2 \cdot log(U))$.

\section{Preflow-push heuristics}

In Section~\ref{sec:preflow}, we defined the generic preflow-push algorithm. In this algorithm, we do not make a particular choice when it comes to select the next operation. In this section, we will define two heuristics that aim to reduce the number of non-saturing pushes which is the bottleneck of the generic preflow-push algorithm \cite{networkflows}.

\subsection{FIFO heuristic}

This algorithm examines the active vertices in the first-in, first-out (FIFO) order. The set of the active vertices is now a queue. The algorithm will always choose the first vertex from the queue while there are active vertices. The algorithm terminates when the queue is empty. 

\subsubsection{Complexity}

To analyze the complexity of the FIFO preflow-push algorithm, we must define the concept of a \textit{vertex examination}. We call vertex examination the sequence of operations that make an active vertex inactive or relabeled. For example, the algorithm could perfom several saturing pushes, leaving the first vertex of the queue active. Then the algorithm could make a non-saturing push or could relabel the vertex. We refer to this sequence of operations as a vertex examination.\\

We will partition the total number of vertex examinations into phases. The first phase consists of the vertex examinations of the vertices that becomes actives in the preprocess operation (the neighbors of the source). After all those specific vertices have been examinated, we enter in the second phase. The second phase consists of the vertex examinations of the vertices that are in the queue at this moment (i.e. when the vertices of the first phase has been all examinated). And so on.\\

To bound the number of phases in the algorithm, we define the potential function $\phi = max\{h(i) : i\text{ is active}\}$ where $h(i)$ is the height of the vertex $i$.

During a phase, the algorithm can perform at most one relabel operation. In the first case, the excess of every vertex that was active at the beginning of the phase moves to vertices with smaller height labels and $\phi$ decreases by at least one unit. In the second case, when the algorithm performs at least one relabel operation during a phase, $\phi$ might increase by as much as the maximum increase in any height label. As we know that the maximum number of relabel operation is $2\cdot|V|^2$ (because each label can increases at most $2\cdot|V|$ times), the total increase in $\phi$ over all phases is at most $2\cdot|V|^2$.

With these two cases, we can bound the total number of phases by $2\cdot|V|^2 + |V|$. The FIFO preflow-push algorithm thus runs in $O(|V|^3)$.

\subsection{Highest label heuristic}
\label{sec:hlh}

This algorithm always pushes flow from the active vertex with the highest height label. 

\subsubsection{Complexity}

It is fearly easy to develop an $O(|V|^3)$ bound for this algorithm. We define the function $h^{*} = max\{h(i): i\text{ is active}\}$. First, the algorithm examines the active vertices with distance labels equal to $h^{*}$ and pushes flow to active vertices with distance labels equal to $h^{*}-1$ and these vertices, in turn, push flow to active vertices with distance labels equal to $h^{*}-2$, and so on. These operations stop when there is no more active vertices or the algorithm relabels a vertex. If the algorithm relabel a vertex, these operations are repeated. In the worst case, the algorithm makes $|V| - 1$ vertex examinations and then relabel a vertex. As we know that the maximum of relabel operations is $2\cdot|V|^2$, the highest label preflow-push algorithm runs in $O(|V|^3)$.\\

However, this bound is rather loose and can be improved by a more clever analysis. We will first define some concepts and functions used to compute the complexity of the algorithm.\\

We define the \textit{set of admissible arcs} as the set, at some point of the execution of the algorithm, of all the arcs $(u, v)$ such that $h(u) = h(v) + 1$. This set forms a \textit{forest} (a set of trees) because it has at most $n - 1$ arcs,  at most one incoming arc per vertex, and does not contain any cycle. The root of each of these trees is the vertex without any incoming arc. 

For any vertex $i \in V$, we denote $D(i)$ the set of descendants of that vertex in the set of admissible arcs. The height label of the descendants of any vertex $i$ will always be higher than $h(i)$. 

An active vertex with no active descendants (other than itself) will be called a \textit{maximal active vertex}. We denote the set of the maximal active vertices $H$.

We define the potential function $\phi = \sum_{i \in H} \phi(i)$ with $\phi(i) = max\{0, K + 1 - |D(i)|\}$ where $K$ is a constant that we will define later. For any vertex $i$, $\phi(i)$ is at most $K$ because $|D(i)| \ge 1$.\\

We will now see how each operations performed by the algorithm will change the value of $\phi$. First, a non-saturing push on the arc $(i, j)$ will make $i$ inactive and $j$ might become a new maximal active vertex. Since $|D(j)| > |D(i)|$, this push increase $\phi(i) + \phi(j)$ by at least one if $|D(i)| \le K$. When a saturing push occurs on the arc $(i, j)$, this arc becomes inadmissible and will be no more in the current forest (the set of admissible arcs). The vertex $i$ is no more a maximal active vertex and $j$ might become a new maximal vertex. This operation increases $\phi$ up to $K$ units. Let's consider now a relabel operation on the vertex $i$. This vertex has no admissible arcs because we relabeled it. Thus, this vertex is a root vertex in the current forest and it has no active proper descendants. After the relabel operation, all the incoming arcs at vertex $i$ become inadmissible. Therefore, all the current arc entering vertex $i$ will no longer belong to the current forest. The relabel operation decreases the number of descendants of $i$ by one: $\phi$ increases by at most $K$. The last operation is to introduce new arcs in the current forest. This does not create new maximal active vertices and might remove maximal active vertices and increase the number of descendants of some vertices. Thus, $\phi$ does not increase.\\

To compute the worst-case, we define $h_{max} = max\{h(i) : i\text{ is active}\}$. A phase is the sequence of pushes during which $d_{max}$ remains unchanged. There are $O(|V|^2)$ phases because there can't be more than $2\cdot|V|^2$ relabel operations. We distinguish two types of phases: \textit{cheap} phases and \textit{expensive} phases. A phase is cheap when it performs at most $\frac{2\cdot|V|}{K}$ non-saturing pushes and expensive otherwise. The number of non-saturing pushes in cheap phases is at most $O(|V|^2 \cdot \frac{2\cdot|V|}{K}) = O(\frac{|V|^3}{K})$.

By definition, an expensive phase performs at least $\frac{2\cdot|V|}{K}$ non-saturing pushes. Since the network can contain at most $\frac{|V|}{K}$ vertices with $K$ descendants or more, at least $\frac{|V|}{K}$ non-saturing pushes must be from vertices with fewer than $K$ descendants. As we said earlier, the total increase of $\phi$ due to saturing pushes and relabels is at most $O(|V|\cdot|E|\cdot K)$. The algorithm perform $O(|V|\cdot|E|\cdot K)$ non-saturing pushes in expensive phases.\\

By balancing the complexity of each case, we obtain the optimal value of $K$ when both are equal: $\frac{|V|^3}{K} = |V|\cdot|E|\cdot K$ or $K = \frac{|V|}{\sqrt{|E|}}$. We have now the number of non-saturing pushes: $O(|V|^2\cdot\sqrt{|E|})$ which is the complexity of our algorithm.\\

Textbooks do not provide a description of the data structure used to enforce the highest label heuristic. We implemented a custom data structure based on the idea of Fran\c cois Aubry, PhD student at UCL. We therefore show how to implement such a data structure with $O(1)$ operation.

\subsubsection{The ActiveSet}

The data structure is divided in two parts: the ActiveSet and the next array. The ActiveSet, as shown on Figure~\ref{fig:tower}, is a array of linked lists of size $|V|\cdot 2$. The ActiveSet can be defined as follows: $activeSet(k) = \{i : i \text{ is active and } h(i) = k\} \text{ } \forall \text{ } 0 \le k < |V|\cdot 2$. When a vertex becomes active, it is added to the linked list at the index of the array corresponding to his height. The next array is an integer array of size $|V| \cdot 2$ where all of his element are pointers to the next non empty list. For example, let's take the case of the Figure~\ref{fig:TheTower}, where there is no active vertices with heights between 3 and $2 \cdot |V|-1$ (all active vertices are shown in the figure). The first (top) element of the data structure is 9 and the second is 6. In the next array, the value at the index $h(9)$ must be equals to $h(6)$ and so on. Note that the minimum height of the active vertex must point to $-1$ because there is no following elements. A variable is used to point at the top of the ActiveSet. Here is the operations needed:

\begin{description}
	\item[getTop] Give the top element of the ActiveSet. It is used when the highest label preflow-push algorithm must examine a vertex;
	\item[add] When a vertex become active, the vertex is added to the ActiveSet;
	\item[updateTop] Used when the top vertex is relabeled;
	\item[removeTop] Used when the top vertex is no longer active (i.e. when there is a non-saturing push);
	\item[isEmpty] Used to know when the ActiveSet is empty. When the ActiveSet is empty, the algorithm terminates.
\end{description}

\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=.4]{images/thetower.png}
  \caption{The ActiveSet}
  \label{fig:tower}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[scale=.4]{images/thenext.png}
  \caption{The next array}
  \label{fig:next}
\end{subfigure}
\caption{The data structure}
\label{fig:TheTower}
\end{figure}

\section{No initialization of height in Preflow-push algorithms}
\label{sec:hauteurs}

%% Décrire la phase de préflow
In the Preflow-push algorithm, there is an initialization phase, called \textit{preprocess}, used to compute the height label of the vertices and performs a saturing push on all the edges leave the source. The computation of the height labels can be performed in $O(|V|)$ with a simple breath first search from the sink (see Algorithm~\ref{algo:bfsinit}). This computation performs $|V|$ relabelings. But what happens if we do not compute the height labels before (i.e. all the height label will be equals to zero) ? In fact, the number of relabeling will be the same. If we do not compute the height labels before, any active vertices will be relabeled before to be able to make a first push because the active vertex will be at height zero and his neighbours too. From that, to case can arise: first, the push is non-saturing. It means that the vertex is no longer active, and the new active vertex need to be relabeled in order to be able to make a push from it. So there is no more relabeling operations than if we compute the height labels in the preprocess. In the second case, the push is saturing: the vertex is still active. In this case, this vertex can push directly into an other neighbour because is height label has already been set at one unit higher than his neighbours. In these two cases, there is not unnecessary relabeling operation. In term of relabeling, there is no gain to compute the height labels in the preprocess. \\

\begin{algorithm}
$parents$ $\gets$ fill($-1$)\;
Queue $q\gets$ new Queue\;
$q$.Enqueue(sink)\;
$sink.h$ = 0\;
\While{q is not empty}{
  $u \gets q$.Dequeue()\;
  \For{every vertex v adjacent of u}{
    \If{v.h equals to 0}{
      parents[$v$] $\gets u$ \;
      $v.h \gets parents[v].h + 1$ \;
      $q$.Enqueue($v$)\;
    }
  }
}

\caption{The computation of the height labels.}
\label{algo:bfsinit}
\end{algorithm}

However, not making this computation could prevent the highest label heuristic (Section~\ref{sec:hlh}) to perfoms at his best. We will analyze this in the experimental analysis (Chapter~\ref{analysis}).






