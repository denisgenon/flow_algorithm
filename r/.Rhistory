for (i in 1:4)
{
codon <- codons[i]
occurrences <- matchPattern(codon, sequence)
print(occurrences)
codonpositions <- attr(occurrences,'start')
print(codonpositions)
numoccurrences <- length(codonpositions)
if (i == 1)
{
#print("Positions initialisé")
positions <- codonpositions
types <- rep(codon, numoccurrences)
}
else
{
#print("Positions append")
positions   <- append(positions, codonpositions, after=length(positions))
types       <- append(types, rep(codon, numoccurrences), after=length(types))
}
#print("Dans la boucle ")
#print(positions)
}
#print("Hors de la boucle ")
#print(positions)
indices <- order(positions)
positions <- positions[indices]
types <- types[indices]
mylist <- list(positions,types)
return(mylist)
}
findPotentialStartsAndStops(s1)
findPotentialStartsAndStops <- function(sequence)
{
codons <- c("atg", "taa", "tag", "tga")
for (i in 1:4)
{
codon <- codons[i]
occurrences <- matchPattern(codon, sequence)
print(occurrences)
codonpositions <- attr(occurrences,'start')
print(as.matrix(occurences))
print(codonpositions)
numoccurrences <- length(codonpositions)
if (i == 1)
{
#print("Positions initialisé")
positions <- codonpositions
types <- rep(codon, numoccurrences)
}
else
{
#print("Positions append")
positions   <- append(positions, codonpositions, after=length(positions))
types       <- append(types, rep(codon, numoccurrences), after=length(types))
}
#print("Dans la boucle ")
#print(positions)
}
#print("Hors de la boucle ")
#print(positions)
indices <- order(positions)
positions <- positions[indices]
types <- types[indices]
mylist <- list(positions,types)
return(mylist)
}
findPotentialStartsAndStops(s1)
findPotentialStartsAndStops <- function(sequence)
{
codons <- c("atg", "taa", "tag", "tga")
for (i in 1:4)
{
codon <- codons[i]
occurrences <- matchPattern(codon, sequence)
print(occurrences)
codonpositions <- attr(occurrences,'start')
print(as.matrix(occurrences))
print(codonpositions)
numoccurrences <- length(codonpositions)
if (i == 1)
{
#print("Positions initialisé")
positions <- codonpositions
types <- rep(codon, numoccurrences)
}
else
{
#print("Positions append")
positions   <- append(positions, codonpositions, after=length(positions))
types       <- append(types, rep(codon, numoccurrences), after=length(types))
}
#print("Dans la boucle ")
#print(positions)
}
#print("Hors de la boucle ")
#print(positions)
indices <- order(positions)
positions <- positions[indices]
types <- types[indices]
mylist <- list(positions,types)
return(mylist)
}
findPotentialStartsAndStops(s1)
matchPattern("atg",s1)
m = matchPattern("atg",s1)
m
m@start
m@ranges@start
findPotentialStartsAndStops <- function(sequence)
{
codons <- c("atg", "taa", "tag", "tga")
for (i in 1:4)
{
codon <- codons[i]
occurrences <- matchPattern(codon, sequence)
#codonpositions <- attr(occurrences,'start')
codonpositions <- occurrences@ranges@start
numoccurrences <- length(codonpositions)
if (i == 1)
{
#print("Positions initialisé")
positions <- codonpositions
types <- rep(codon, numoccurrences)
}
else
{
#print("Positions append")
positions   <- append(positions, codonpositions, after=length(positions))
types       <- append(types, rep(codon, numoccurrences), after=length(types))
}
#print("Dans la boucle ")
#print(positions)
}
#print("Hors de la boucle ")
#print(positions)
indices <- order(positions)
positions <- positions[indices]
types <- types[indices]
mylist <- list(positions,types)
return(mylist)
}
findPotentialStartsAndStops(s1)
findPotentialStartsAndStops <- function(sequence)
{
codons <- c("ttg", "ctg", "ata", "att", "atc", "gtg", "atg", "taa", "tag", "tga")
for (i in 1:10)
{
codon <- codons[i]
occurrences <- matchPattern(codon, sequence)
#codonpositions <- attr(occurrences,'start')
codonpositions <- occurrences@ranges@start
numoccurrences <- length(codonpositions)
if (i < 8)
{
positions <- codonpositions
types <- rep(codon, numoccurrences)
}
else
{
positions   <- append(positions, codonpositions, after=length(positions))
types       <- append(types, rep(codon, numoccurrences), after=length(types))
}
}
indices <- order(positions)
positions <- positions[indices]
types <- types[indices]
mylist <- list(positions,types)
return(mylist)
}
findORFsinSeq <- function(sequence)
{
require(Biostrings)
# Make vectors "positions" and "types" containing information on the positions of ATGs in the sequence:
mylist <- findPotentialStartsAndStops(sequence)
positions <- mylist[[1]]
types <- mylist[[2]]
# Make vectors "orfstarts" and "orfstops" to store the predicted start and stop codons of ORFs
orfstarts <- numeric()
orfstops <- numeric()
# Make a vector "orflengths" to store the lengths of the ORFs
orflengths <- numeric()
# Print out the positions of ORFs in the sequence:
# Find the length of vector "positions"
numpositions <- length(positions)
# There must be at least one start codon and one stop codon to have an ORF.
if (numpositions >= 2)
{
for (i in 1:(numpositions-1))
{
posi <- positions[i]
typei <- types[i]
found <- 0
while (found == 0)
{
for (j in (i+1):numpositions)
{
posj  <- positions[j]
typej <- types[j]
posdiff <- posj - posi
posdiffmod3 <- posdiff %% 3
# Add in the length of the stop codon
orflength <- posj - posi + 3
if (typei == "atg" && (typej == "taa" || typej == "tag" || typej == "tga") && posdiffmod3 == 0)
{
# Check if we have already used the stop codon at posj+2 in an ORF
numorfs <- length(orfstops)
usedstop <- -1
if (numorfs > 0)
{
for (k in 1:numorfs)
{
orfstopk <- orfstops[k]
if (orfstopk == (posj + 2)) { usedstop <- 1 }
}
}
if (usedstop == -1)
{
orfstarts <- append(orfstarts, posi, after=length(orfstarts))
orfstops <- append(orfstops, posj+2, after=length(orfstops)) # Including the stop codon.
orflengths <- append(orflengths, orflength, after=length(orflengths))
}
found <- 1
break
}
if (j == numpositions) { found <- 1 }
}
}
}
}
# Sort the final ORFs by start position:
indices <- order(orfstarts)
orfstarts <- orfstarts[indices]
orfstops <- orfstops[indices]
# Find the lengths of the ORFs that we have
orflengths <- numeric()
numorfs <- length(orfstarts)
for (i in 1:numorfs)
{
orfstart <- orfstarts[i]
orfstop <- orfstops[i]
orflength <- orfstop - orfstart + 1
orflengths <- append(orflengths,orflength,after=length(orflengths))
}
mylist <- list(orfstarts, orfstops, orflengths)
return(mylist)
}
findPotentialStartsAndStops <- function(sequence)
{
codons <- c("ttg", "ctg", "ata", "att", "atc", "gtg", "atg", "taa", "tag", "tga")
for (i in 1:10)
{
codon <- codons[i]
occurrences <- matchPattern(codon, sequence)
#codonpositions <- attr(occurrences,'start')
codonpositions <- occurrences@ranges@start
numoccurrences <- length(codonpositions)
if (i == 1)
{
positions <- codonpositions
types <- rep(codon, numoccurrences)
}
else
{
positions   <- append(positions, codonpositions, after=length(positions))
types       <- append(types, rep(codon, numoccurrences), after=length(types))
}
}
indices <- order(positions)
positions <- positions[indices]
types <- types[indices]
mylist <- list(positions,types)
return(mylist)
}
findORFsinSeq <- function(sequence)
{
require(Biostrings)
# Make vectors "positions" and "types" containing information on the positions of ATGs in the sequence:
mylist <- findPotentialStartsAndStops(sequence)
positions <- mylist[[1]]
types <- mylist[[2]]
# Make vectors "orfstarts" and "orfstops" to store the predicted start and stop codons of ORFs
orfstarts <- numeric()
orfstops <- numeric()
# Make a vector "orflengths" to store the lengths of the ORFs
orflengths <- numeric()
# Print out the positions of ORFs in the sequence:
# Find the length of vector "positions"
numpositions <- length(positions)
# There must be at least one start codon and one stop codon to have an ORF.
if (numpositions >= 2)
{
for (i in 1:(numpositions-1))
{
posi <- positions[i]
typei <- types[i]
found <- 0
while (found == 0)
{
for (j in (i+1):numpositions)
{
posj  <- positions[j]
typej <- types[j]
posdiff <- posj - posi
posdiffmod3 <- posdiff %% 3
# Add in the length of the stop codon
orflength <- posj - posi + 3
if ((typei == "ttg" || typei == "ctg" || typei == "ata" || typei == "att" || typei == "atc" || typei == "atg" || typei == "gtg") && (typej == "tga" || typej == "taa" || typej == "tag") && posdiffmod3 == 0)
{
# Check if we have already used the stop codon at posj+2 in an ORF
numorfs <- length(orfstops)
usedstop <- -1
if (numorfs > 0)
{
for (k in 1:numorfs)
{
orfstopk <- orfstops[k]
if (orfstopk == (posj + 2)) { usedstop <- 1 }
}
}
if (usedstop == -1)
{
orfstarts <- append(orfstarts, posi, after=length(orfstarts))
orfstops <- append(orfstops, posj+2, after=length(orfstops)) # Including the stop codon.
orflengths <- append(orflengths, orflength, after=length(orflengths))
}
found <- 1
break
}
if (j == numpositions) { found <- 1 }
}
}
}
}
# Sort the final ORFs by start position:
indices <- order(orfstarts)
orfstarts <- orfstarts[indices]
orfstops <- orfstops[indices]
# Find the lengths of the ORFs that we have
orflengths <- numeric()
numorfs <- length(orfstarts)
for (i in 1:numorfs)
{
orfstart <- orfstarts[i]
orfstop <- orfstops[i]
orflength <- orfstop - orfstart + 1
orflengths <- append(orflengths,orflength,after=length(orflengths))
}
mylist <- list(orfstarts, orfstops, orflengths)
return(mylist)
}
findORFsinSeq(s1)
seq <- read.fasta(file = "Strep.fasta")
library("seqinr")
seq <- read.fasta(file = "Strep.fasta")
seq <- read.fasta(file = "Strep.fasta")
trueseq <- seq[[1]]
trueseq
stringseq <- c2c(truesqe)
seq <- getncbiseq("NZ_JFIS01000023")
stringseq <- c2s(trueseq)
findORFsinSeq(stringseq)
lenghts = findORFsinSeq(stringseq)[[3]]
lenghts
order(lenghts)
lenghts
sort(lenghts)
length(seq)
length(trueseq)
lengths <- sort(lenghts)
getNumber <- function(vector, int)
{
count=0
for(i in vector){
if (i>=int) {
count=count+1
}
}
return count
}
getNumber <- function(vector, int)
{
count=0
for(i in vector){
if (i>=int) {
count=count+1
}
}
return(count)
}
getNumber(lengths,10)
getNumber(lengths,50)
getNumber(lengths,100)
getNumber(lengths,300)
getNumber(lengths,500)
rss <- tolower(as.character(reverseComplement(DNAStringSet(stringseq))[[1]])
rss <- tolower(as.character(reverseComplement(DNAStringSet(stringseq))[[1]]))
rss
newl = findORFsinSeq(stringseq)[[3]]
getNumber(newl,10)
getNumber(newl,50)
getNumber(newl,100)
newl = findORFsinSeq(rss)[[3]]
getNumber(newl,10)
getNumber(newl,50)
getNumber(newl,100)
getNumber(newl,300)
getNumber(newl,500)
sample(stringseq,length(stringseq))
unlist(strsplit(stringseq, split=""))
vectorseq <- unlist(strsplit(stringseq, split=""))
randomseq <- sample(vectorseq,length(vectorseq))
randomseq <- c(randomseq)
randomseq <- c2s(randomseq)
rrs <- tolower(as.character(reverseComplement(DNAStringSet(randomseq))[[1]]))
newrl = findORFsinSeq(randomseq)[[3]]
getNumber(newrl,10)
getNumber(newrl,50)
getNumber(newrl,100)
getNumber(newrl,300)
getNumber(newrl,500)
sort(newrl)
newrl = findORFsinSeq(rrs)[[3]]
sort(newrl)
sort(newl)
getNumber(newl,624)
getNumber(newl,372)
getNumber(lengths,372)
bigdata = c(lengths,newl)
bigdata = sort(bigdata)
bigdata
getNumber(bigdata,372)
getNumber(bigdata,633)
newl = findORFsinSeq(randomseq)[[3]]
randombigdata = c(newl,newrl)
sort(randombigdata)
getNumber(bigdata,252)
getNumber(bigdata,624)
getNumber(findORFsinSeq(stringseq)[[3]],2000)
exo4 -> findORFsinSeq(stringseq)
exo4 <- findORFsinSeq(stringseq)
sort(exo4[[3]])
exo4[[3]]
exo4[[1]]
exo4[[2]]
exo4[[1]]
exo4[[3]]
exo4[[1]][213]
exo4[[2]][213]
exo4[[3]][213]
7748%%3
stringseq[7748,10102]
stringse([7748,10102)
substr(stringseq,7748,10102)
getNumber(bigdata,252)
getNumber(bigdata,372)
substr("abcdef", 2, 4)
strinseq
stringseq
# Uncomment the following line to install ggplot2, install only one time the package!
#install.packages("ggplot2")
library('ggplot2')
instances=c(4)
solvers=c("Edmonds-Karp","Ford-Fulkerson Scaling","Push-Relabel")
for (instance in instances){
for (solver in solvers){
print("OK")
f = paste(c("../java/results/resultsBySolver/", solver, instance,".csv"), collapse="")
title = paste(c(solver, " Instance ", instance), collapse="")
filename = paste(c("../graphiques/",title,".png"), collapse="")
results <- read.csv(file=f, head=TRUE, sep=",")
attach(results)
ggplot() +
geom_line(data = results, aes(x = Instances, y = LinkedList, color = 'Linked List')) +
geom_line(data = results, aes(x = Instances, y = HashMap, color = 'HashMap')) +
geom_line(data = results, aes(x = Instances, y = SplitArray, color = 'Split Array')) +
geom_line(data = results, aes(x = Instances, y = TreeMap, color = 'TreeMap')) +
geom_line(data = results, aes(x = Instances, y = SparseMap, color = 'SparseMap')) +
xlab('Density of edges') +
ylab('Time (ms)') +
labs(color="Data structure") +
ggtitle(title)
ggsave(file=filename)
}
}
setwd("C:/Users/victor/git/flow_algorithm_new/r")
# Uncomment the following line to install ggplot2, install only one time the package!
#install.packages("ggplot2")
library('ggplot2')
instances=c(4)
solvers=c("Edmonds-Karp","Ford-Fulkerson Scaling","Push-Relabel")
for (instance in instances){
for (solver in solvers){
print("OK")
f = paste(c("../java/results/resultsBySolver/", solver, instance,".csv"), collapse="")
title = paste(c(solver, " Instance ", instance), collapse="")
filename = paste(c("../graphiques/",title,".png"), collapse="")
results <- read.csv(file=f, head=TRUE, sep=",")
attach(results)
ggplot() +
geom_line(data = results, aes(x = Instances, y = LinkedList, color = 'Linked List')) +
geom_line(data = results, aes(x = Instances, y = HashMap, color = 'HashMap')) +
geom_line(data = results, aes(x = Instances, y = SplitArray, color = 'Split Array')) +
geom_line(data = results, aes(x = Instances, y = TreeMap, color = 'TreeMap')) +
geom_line(data = results, aes(x = Instances, y = SparseMap, color = 'SparseMap')) +
xlab('Density of edges') +
ylab('Time (ms)') +
labs(color="Data structure") +
ggtitle(title)
ggsave(file=filename)
}
}
